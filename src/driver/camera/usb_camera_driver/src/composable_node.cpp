#include "usb_camera_driver/composable_node.hpp"

USBCameraDriverNode::USBCameraDriverNode(const rclcpp::NodeOptions& options)
: Node("usb_camera_driver_node", options)
{
    // GStreamerの初期化をここに追加
    if (!gst_is_initialized()) {
        gst_init(nullptr, nullptr);
    }
    
    RCLCPP_INFO(this->get_logger(), "USB Camera Driver Node has been started.");

    // Declare and get parameters
    this->declare_parameter<std::string>("camera_device", "/dev/video0");
    this->declare_parameter<int>("image_width", 640);
    this->declare_parameter<int>("image_height", 480);
    this->declare_parameter<int>("framerate", 30);
    this->declare_parameter<std::string>("camera_frame_id", "camera_link");
    this->declare_parameter<std::string>("compressed_image_topic_name", "image_raw");
    this->declare_parameter<std::string>("camera_info_topic_name", "camera_info");

    camera_device_ = this->get_parameter("camera_device").as_string();
    image_width_ = this->get_parameter("image_width").as_int();
    image_height_ = this->get_parameter("image_height").as_int();
    framerate_ = this->get_parameter("framerate").as_int();
    camera_frame_id_ = this->get_parameter("camera_frame_id").as_string();
    compressed_image_topic_name_ = this->get_parameter("compressed_image_topic_name").as_string();
    camera_info_topic_name_ = this->get_parameter("camera_info_topic_name").as_string();

    RCLCPP_INFO(this->get_logger(), "Camera Device: %s", camera_device_.c_str());
    RCLCPP_INFO(this->get_logger(), "Resolution: %dx%d", image_width_, image_height_);
    RCLCPP_INFO(this->get_logger(), "Framerate: %d fps", framerate_);
    RCLCPP_INFO(this->get_logger(), "Camera Frame ID: %s", camera_frame_id_.c_str());

    // QoS settings (for high-speed image streaming)
    // Best effort: send the latest data possible, discard old data
    // Durability volatile: subscribers receive the latest data even if the publisher is not active
    // History keep_last: keep the last 10 messages
    rclcpp::QoS qos_profile = rclcpp::QoS(rclcpp::KeepLast(10)).best_effort().durability_volatile();

    // Create publishers
    compressed_image_publisher_ = this->create_publisher<sensor_msgs::msg::CompressedImage>(compressed_image_topic_name_, qos_profile);
    camera_info_publisher_ = this->create_publisher<sensor_msgs::msg::CameraInfo>(camera_info_topic_name_, qos_profile);

    // Initialize camera info (placeholder if no calibration data is available)
    // In actual operation, please use information generated by calibration tools.
    camera_info_msg_.header.frame_id = camera_frame_id_;
    camera_info_msg_.width = image_width_;
    camera_info_msg_.height = image_height_;
    // K (intrinsic matrix) and P (projection matrix) are set after calibration
    // D (distortion coefficients) are also similar
    // Placeholder values here
    camera_info_msg_.k = {1.0, 0.0, static_cast<double>(image_width_) / 2.0,
                            0.0, 1.0, static_cast<double>(image_height_) / 2.0,
                            0.0, 0.0, 1.0};
    camera_info_msg_.p = {1.0, 0.0, static_cast<double>(image_width_) / 2.0, 0.0,
                            0.0, 1.0, static_cast<double>(image_height_) / 2.0, 0.0,
                            0.0, 0.0, 1.0, 0.0};
    camera_info_msg_.distortion_model = "plumb_bob"; // Common distortion model

    // Start camera capture in a separate thread
    capture_thread_ = std::thread(&USBCameraDriverNode::capture_and_publish, this);
}

USBCameraDriverNode::~USBCameraDriverNode()
{
    if (capture_thread_.joinable()) {
        capture_thread_.join(); // スレッドの終了を待機
                                // Wait for thread to finish
    }
    RCLCPP_INFO(this->get_logger(), "USB Camera Driver Node has been stopped.");
}

void USBCameraDriverNode::capture_and_publish()
{
    gstreamer_pipeline_ = "v4l2src device=" + camera_device_ +
                            " ! video/x-raw,format=YUY2,width=" + std::to_string(image_width_) +
                            ",height=" + std::to_string(image_height_) +
                            ",framerate=" + std::to_string(framerate_) + "/1" +
                            " ! videoconvert" +
                            " ! video/x-raw,format=I420" +  // <-- v4l2h264encが受け付けるフォーマットに変換、 v4l2h264encがI420を要求することが多い
                            " ! v4l2h264enc" +              // <-- ハードウェアエンコード
                            " ! h264parse" +                // <-- H.264ストリームをappsinkが受け取れるようにする
                            " ! appsink name=ros_sink emit-signals=true sync=false drop=true";

    RCLCPP_INFO(this->get_logger(), "GStreamer Pipeline: %s", gstreamer_pipeline_.c_str());

    GError *error = nullptr;
    GstElement *pipeline = gst_parse_launch(gstreamer_pipeline_.c_str(), &error);

    if (error) {
        RCLCPP_ERROR(this->get_logger(), "Failed to create GStreamer pipeline: %s", error->message);
        g_error_free(error);
        return;
    }

    if (!pipeline) {
        RCLCPP_ERROR(this->get_logger(), "Failed to create GStreamer pipeline.");
        return;
    }

    GstElement *appsink = gst_bin_get_by_name(GST_BIN(pipeline), "ros_sink");
    if (!appsink) {
        RCLCPP_ERROR(this->get_logger(), "Failed to get appsink 'ros_sink' from pipeline.");
        gst_object_unref(pipeline);
        return;
    }

    // コールバック関数を設定
    g_signal_connect(appsink, "new-sample", G_CALLBACK(on_new_sample), this);
    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink), TRUE);
    gst_app_sink_set_drop(GST_APP_SINK(appsink), TRUE);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink), 1);

    // パイプラインの状態をPLAYINGに変更し、開始
    gst_element_set_state(pipeline, GST_STATE_PLAYING);

    // ROS 2ノードがシャットダウンされるまで待機
    // このスレッドはここでブロックされるのではなく、ROS 2のrclcpp::ok()でループを続ける
    // GStreamerのコールバックが別スレッドで実行されるため、メインのROS 2スレッドはspin()でイベントループを回す
    // この例ではcapture_thread_でこの関数を実行するため、GStreamerは別のスレッドで動作し、
    // ROSのコールバックもこのスレッド内で実行される
    RCLCPP_INFO(this->get_logger(), "Camera opened successfully. Starting capture loop.");

    // GStreamerのメインループ（GLibのメインループ）を動かす必要がある場合、これが必要
    // この例では、ROS 2のspin()に任せるか、GStreamerのパイプラインを別スレッドで管理する
    GstMessage *msg = nullptr;
    while (rclcpp::ok() && (msg = gst_bus_timed_pop_filtered(
        gst_element_get_bus(pipeline), 
        GST_CLOCK_TIME_NONE, 
        (GstMessageType)(GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS)))
    ) {
        // メッセージ処理
        // ...
        gst_message_unref(msg);
    }
    
    // クリーンアップ
    gst_element_set_state(pipeline, GST_STATE_NULL);
    gst_object_unref(appsink);
    gst_object_unref(pipeline);
}

// appsinkのコールバック関数
static GstFlowReturn on_new_sample(GstElement *sink, gpointer user_data)
{
    USBCameraDriverNode *node = reinterpret_cast<USBCameraDriverNode*>(user_data);
    
    // GstSampleからGstBufferを取得
    GstSample *sample = gst_app_sink_pull_sample(GST_APP_SINK(sink));
    if (!sample) {
        return GST_FLOW_OK;
    }

    GstBuffer *buffer = gst_sample_get_buffer(sample);
    if (!buffer) {
        gst_sample_unref(sample);
        return GST_FLOW_OK;
    }

    // GstBufferからデータポインタとサイズを取得
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    if (map.size > 0) {
        // ROS 2のCompressedImageメッセージを作成
        auto compressed_msg = std::make_unique<sensor_msgs::msg::CompressedImage>();
        
        // ヘッダーを設定
        compressed_msg->header.frame_id = node->get_parameter("camera_frame_id").as_string();
        compressed_msg->header.stamp = node->now();
        
        // H.264のフォーマットとデータを格納
        compressed_msg->format = "h264";
        compressed_msg->data.assign(map.data, map.data + map.size);

        // パブリッシュ
        node->compressed_image_publisher_->publish(std::move(compressed_msg));
    }

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

// This macro registers the node as a shared library
RCLCPP_COMPONENTS_REGISTER_NODE(USBCameraDriverNode)

// The main function is not needed for composable nodes as they are loaded by a container.
// int main(int argc, char * argv[])
// {
//     rclcpp::init(argc, argv);
//     rclcpp::spin(std::make_shared<USBCameraDriverNode>(rclcpp::NodeOptions()));
//     rclcpp::shutdown();
//     return 0;
// }

